import * as vscode from "vscode";

import { promises as fsPromises } from "fs";
import { PreviewEditPanel } from "./previewEditPanel";
import * as path from "path";
import { ResxEditorProvider } from "./resxEditorProvider";
import { NotificationService } from "./notificationService";
import * as childProcess from "child_process";
import { FileHelper } from "./fileHelper";
import { ObjectOfStrings, js2resx, resx2js } from "resx"
import { ResxData, ResxOOS } from "./resxData";

let currentContext: vscode.ExtensionContext;
var shouldGenerateStronglyTypedResourceClassOnSave: boolean = false

export function activate(context: vscode.ExtensionContext) {
	try {
		const notificationService = new NotificationService(context);
		notificationService.promptForReviewAsync();
	}
	catch (error) {
		console.error(error);
	}

	currentContext = context;
	loadConfiguration();

	vscode.workspace.onDidChangeConfiguration(() => {
		loadConfiguration();
	});

	context.subscriptions.push(vscode.commands.registerTextEditorCommand("resxpress.resxpreview",
		async () => {
			vscode.window.withProgress(
				{
					location: vscode.ProgressLocation.Notification,
					cancellable: false,
					title: "ResXpress",
				},
				async (p) => {
					p.report({ message: "Showing Preview" });
					await displayAsMarkdown();
				}
			);
		}));

	context.subscriptions.push(vscode.commands.registerTextEditorCommand("resxpress.sortbykeys",
		async () => {
			vscode.window.withProgress(
				{
					location: vscode.ProgressLocation.Notification,
					cancellable: false,
					title: "ResXpress",
				},
				async (p) => {
					p.report({ message: "Sorting by keys" });
					await sortByKeys();
				}
			);
		}));

	context.subscriptions.push(vscode.commands.registerTextEditorCommand("resxpress.newpreview",
		async () => {
			vscode.window.withProgress(
				{
					location: vscode.ProgressLocation.Notification,
					cancellable: false,
					title: "ResXpress",
				},
				async (p) => {
					p.report({ message: "Showing Web Preview" });
					await newPreview();
				}
			);
		}
	)
	);

	context.subscriptions.push(vscode.commands.registerTextEditorCommand("resxpress.resxeditor", async () => { await newPreview(); }));

	context.subscriptions.push(ResxEditorProvider.register(context));

	vscode.workspace.onDidSaveTextDocument(async (documentSavedEvent) => {
		try {
			var isResx = documentSavedEvent.fileName.endsWith(".resx");
			if (isResx && shouldGenerateStronglyTypedResourceClassOnSave) {
				await runResGenAsync(documentSavedEvent.fileName);
			}
		}
		catch (error) {
			var errorMessage = "";
			if (error instanceof Error) {
				errorMessage = error.message;
			}
			else if (typeof error === "string") {
				errorMessage = error;
			}
			console.error(error);
			vscode.window.showErrorMessage(errorMessage);
		}
	});

	console.log(`Extension ${context.extension.id} activated`);
}

function loadConfiguration() {
	let resxConfig = vscode.workspace.getConfiguration("resxpress.configuration");
	shouldGenerateStronglyTypedResourceClassOnSave = resxConfig.get<boolean>("generateStronglyTypedResourceClassOnSave") ?? false;
}

export async function runResGenAsync(fileName: string): Promise<void> {
	let filename = FileHelper.getFileName();
	let csharpFileName = "Resources.cs";
	if (filename !== null) {
		csharpFileName = `${filename}.Designer.cs`;
	}

	let nameSpace = await FileHelper.tryGetNamespace();
	if (nameSpace === null || nameSpace === "") {
		nameSpace = path.basename(path.dirname(fileName));
	}

	if (process.platform != "win32") {

		var ext = "cs";

		let parameter = `/str:${ext},${nameSpace},,${csharpFileName}`
		console.log("Parameter: " + parameter);
		const cli = childProcess.spawn("ResGen", [`${fileName}`, "/useSourcePath", parameter], { stdio: ["pipe"] });

		var stdOutData = "";
		var stdErrData = "";
		cli.stdout.setEncoding("utf8");
		cli.stdout.on("data", data => {
			stdOutData += data;
		});

		cli.stderr.setEncoding("utf8");
		cli.stderr.on("data", data => {
			stdErrData += data;
		});

		let promise = new Promise<void>((resolve, reject) => {
			cli.on("close", (exitCode: number) => {
				if (exitCode !== 0) {
					reject();
					console.log(stdErrData)
				}
				else {
					resolve();
					console.log(stdOutData)
				}
			});
		});
		return promise;
	}
	else {
		let documentText = FileHelper.getActiveDocumentText();
		if (documentText != "") {
			var jsObj = await resx2js(documentText, true);

			var resourceCSharpClassText = "";
			let accessModifier = "public";
			let workspacePath = FileHelper.getDirectory();

			resourceCSharpClassText += `namespace ${nameSpace} 
{
	using System;


	/// <summary>
	///   A strongly-typed resource class, for looking up localized strings, etc.
	/// </summary>
	// This class was auto-generated by the VS Code Extension PrateekMahendrakar.resxpress
	[global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
	[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
	[global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
	${accessModifier} class ${filename} 
	{
		private static global::System.Resources.ResourceManager resourceMan;

		private static global::System.Globalization.CultureInfo resourceCulture;

		[global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
		${accessModifier} ${filename}()
		{
		}

		/// <summary>
		///   Returns the cached ResourceManager instance used by this class.
		/// </summary>
		[global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
		${accessModifier} static global::System.Resources.ResourceManager ResourceManager
		{
			get
			{
				if (object.ReferenceEquals(resourceMan, null))
				{
					global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("ConsoleApp3.Resource1", typeof(Resource1).Assembly);
					resourceMan = temp;
				}
				return resourceMan;
			}
		}

		/// <summary>
		///   Overrides the current thread's CurrentUICulture property for all
		///   resource lookups using this strongly typed resource class.
		/// </summary>
		[global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
		${accessModifier} static global::System.Globalization.CultureInfo Culture
		{
			get
			{
				return resourceCulture;
			}
			set
			{
				resourceCulture = value;
			}
		}
		
		`;

			Object(jsObj).elements.forEach((element: ObjectOfStrings) => {
				if (element.name === "data") {
					const resourceKey = element.key;
					//let valueElementParent = element.elements.filter((x: any) => x.name == "value")?.[0];
					let value = element.value;

					const propertyName = resourceKey.replace(/ /g, "_");
					resourceCSharpClassText += `

		/// <summary>
		/// Looks up a localized string similar to ${value}.
		/// </summary>
		${accessModifier} static string ${propertyName} => ResourceManager.GetString("${resourceKey}", resourceCulture);
	
	`;
				}

			});

			resourceCSharpClassText += `}
}`;
			console.log(resourceCSharpClassText);


			if (workspacePath != null) {
				let pathToWrite = path.join(workspacePath, csharpFileName);
				await FileHelper.writeToFile(pathToWrite, resourceCSharpClassText);
			}
		}
	}
}

// this method is called when your extension is deactivated
export function deactivate() { }

async function sortByKeys() {
	try {
		let unordered = await sortKeyValuesResx();

		let editor = vscode.window.activeTextEditor;

		if (editor && unordered) {
			let document = editor.document;

			var ranger = new vscode.Range(0, 0, document.lineCount, 0);

			editor.edit((editBuilder) => {
				editBuilder.replace(ranger, unordered);
			});
		}
	}
	catch (error) {
		var errorMessage = "";
		if (error instanceof Error) {
			errorMessage = error.message;
		}
		else if (typeof error === "string") {
			errorMessage = error;
		}
		vscode.window.showErrorMessage(errorMessage);
		console.error(error);
	}
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
async function sortKeyValuesResx(reverse?: boolean) {
	try {
		const jsObj = await getDataJs();
		for (const key in jsObj) {
			console.log(key);
		}
		let keysSorted = Object.keys(jsObj).sort();
		let sortedResx: Record<string, ResxData> = {};

		keysSorted.forEach(x => {
			sortedResx[x] = jsObj[x];
		});

		for (const key in sortedResx) {
			console.log(key);
		}

		// eslint-disable-next-line @typescript-eslint/no-unused-vars
		let oos: ResxOOS = {};
		for (const key in sortedResx) {
			
			let obj: any = {};
			obj.value = sortedResx[key].value;
			if (typeof sortedResx[key].comment == "string") {
				obj.comment = sortedResx[key].comment as string;
			}

			oos[key] = obj;
		}

		// eslint-disable-next-line @typescript-eslint/no-unused-vars
		let options = {
			pretty: true, indent: "\t", newline: "\n"};

		let xml = await js2resx(oos);
		return xml;
	}
	catch (error) {
		var errorMessage = "";
		if (error instanceof Error) {
			errorMessage = error.message;
		}
		else if (typeof error === "string") {
			errorMessage = error;
		}
		vscode.window.showErrorMessage(errorMessage);
		console.error(error);
	}
}

async function getDataJs(): Promise<Record<string, ResxData>> {
	var text = vscode.window.activeTextEditor?.document?.getText() ?? "";
	var jsObj: any = await resx2js(text, true);

	var resxKeyValues: Record<string, ResxData> = {};

	Object.entries(jsObj).forEach(([key, value]) => {
		let oos = value as ObjectOfStrings;
		if (oos) {
			let resx = new ResxData(oos.value, oos.comment ?? null);
			resxKeyValues[key] = resx;
		}
	});

	return resxKeyValues;
}
async function newPreview() {
	let jsObj = await getDataJs()
	let currentFileName = vscode.window.activeTextEditor?.document.fileName;
	if (currentFileName) {
		await displayJsonInHtml(jsObj, currentFileName);
	}
}


// Markdown Preview
async function displayAsMarkdown() {
	try {
		var pathObj = path.parse(
			vscode.window.activeTextEditor?.document.fileName ?? ""
		);
		if (pathObj) {
			if (pathObj.ext !== ".resx") {
				await vscode.window.showErrorMessage("Not a Resx file.");
				return;
			}
			const jsonData = await getDataJs();
			if (!(jsonData instanceof Error)) {
				var currentFileName = vscode.window.activeTextEditor?.document.fileName;
				if (currentFileName) {
					var fileNameNoExt = vscode.window.activeTextEditor?.document.fileName.substring(
						0,
						currentFileName.lastIndexOf(".")
					);
					let mdFile = fileNameNoExt + ".md";

					let fileContent = `### ${pathObj.name} Preview\n\n| Key | Value | Comment |\n`;
					fileContent += "| --- | --- | --- |" + "\n";

					for (const key in jsonData) {
						const resxData = jsonData[key];
						const regexM = /[\\`*_{}[\]()#+.!|-]/g;
						//clean up key
						var property = key;
						var propertyString = property;

						propertyString = property.replace(regexM, "\\$&");
						propertyString = property.replace(/\r?\n/g, "<br/>");

						var valueString = resxData.value;
						var commentString = resxData.comment ?? "";

						valueString = valueString.replace(regexM, "\\$&");
						valueString = valueString.replace(/\r?\n/g, "<br/>");
						commentString = commentString.replace(regexM, "\\$&");
						commentString = commentString.replace(/\r?\n/g, "<br/>");

						fileContent += `| ${propertyString} | ${valueString} | ${commentString} |\n`;
					}

					await fsPromises.writeFile(mdFile, fileContent);

					let uri = vscode.Uri.file(mdFile);

					await vscode.commands.executeCommand("vscode.open", uri);
					await vscode.commands.executeCommand("markdown.showPreview");
					await vscode.commands.executeCommand("markdown.preview.refresh");
					await vscode.commands.executeCommand("workbench.action.previousEditor");
					await vscode.commands.executeCommand("workbench.action.closeActiveEditor");
				}
			}
			else {
				vscode.window.showErrorMessage("Error parsing resx data");
			}
		}
		else {
			vscode.window.showErrorMessage("Error finding path of the file");
		}
	}
	catch (error) {
		var errorMessage = "";
		if (error instanceof Error) {
			errorMessage = error.message;
		}
		else if (typeof error === "string") {
			errorMessage = error;
		}
		vscode.window.showErrorMessage(errorMessage);
		console.error(error);
	}
}

async function displayJsonInHtml(jsonData: Record<string, ResxData>, filename: string) {
	try {
		var htmlContent = "";


		for (const key in jsonData) {
			var valueStr = jsonData[key].value;
			var commentstr = jsonData[key].comment ?? "";
			htmlContent += `<tr>
				<td>${key}</td>
				<td>${valueStr}</td>
				<td>${commentstr}</td>
			</tr>`;
		}

		var pathObj = path.parse(filename);
		var title = pathObj.name + pathObj.ext;

		PreviewEditPanel.createOrShow(currentContext.extensionUri, title, htmlContent);
	}
	catch (error) {
		var errorMessage = "";
		if (error instanceof Error) {
			errorMessage = error.message;
		}
		else if (typeof error === "string") {
			errorMessage = error;
		}
		vscode.window.showErrorMessage(errorMessage);
		console.error(error);
	}
}
